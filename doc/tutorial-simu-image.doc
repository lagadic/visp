/**

\page tutorial-simu-image Tutorial: Planar image projection
\tableofcontents

\section simu_image_intro Introduction

The aim of this tutorial is to explain how to use vpImageSimulator class to project an image of a planar scene at a given camera position. For axample, this capability can then be used during the simulation of a visual-servo as described in \ref tutorial-ibvs to introduce an image processing. 

\section simu_image_projection Image projection

Given the image of a planar 20cm by 20cm square target as the one presented in the next image, we show here after how to project this image at a given camera position, and how to get the resulting image. 

\image html img-target-square.png Image of a planar 20cm by 20cm square target. 

This is done by the following code also available in tutorial-image-simulator.cpp:
\include tutorial-image-simulator.cpp

The result of this program is shown in the next image.

\image html img-simu-image-target-square.png Resulting projection of the planar image at a given camera postion.

The provide hereafter the explanation of the new lines that were introduced.

\code
#include <visp/vpImageSimulator.h>
\endcode
Include the header of the vpImageSimulator class that allows to project an image to a given camera position.

Then in the main() function we create an instance of a grey level image that corresponds to the image of the planar target, and then we read the image from the disk. 
\code
  vpImage<unsigned char> target; 
  vpImageIo::read(target, "./target_square.pgm");
\endcode

Since the previous image corresponds to a 20cm by 20cm target, we initialize the 3D coordinates of each corner in the plane Z=0. Each
\code
  vpColVector X[4]; 
  for (int i = 0; i < 4; i++) X[i].resize(3);
  // Top left     Top right       Bottom right   Bottom left
  X[0][0] = -0.1; X[1][0] =  0.1; X[2][0] = 0.1; X[3][0] = -0.1;
  X[0][1] = -0.1; X[1][1] = -0.1; X[2][1] = 0.1; X[3][1] =  0.1;
  X[0][2] =  0;   X[1][2] =  0;   X[2][2] = 0;   X[3][2] =  0;
\endcode

Then we create an instance of the image \c I that will contain the rendered imagefrom a given camera position.
\code
  vpImage<unsigned char> I(480, 640);
\endcode

Since the projection depends on the camera, we set its intrinsic parameters.
\code
  vpCameraParameters cam(840, 840, I.getWidth()/2, I.getHeight()/2);
\endcode

We also set the render position of the camera as an homogeneous transformation between the camera frame and the target frame.
\code
  vpHomogeneousMatrix cMo(0, 0, 0.35, 0, vpMath::rad(30), vpMath::rad(15));
\endcode

We create here an instance of the planar image projector, set the interpolation to bilinear and initialize the projector with the image of the target and the coordinates of its corners.
\code
  vpImageSimulator sim;
  sim.setInterpolationType(vpImageSimulator::BILINEAR_INTERPOLATION);
  sim.init(target, X);
\endcode

Now to retrieve the rendered image we first clean the content of the image to render, set the camera position, and finally get the image using the camera parameters.
\code
  sim.setCleanPreviousImage(true);
  sim.setCameraPosition(cMo);
  sim.getImage(I, cam);
\endcode

Then, if \c libjpeg is available, the rendered image is saved in the same directory then the executable.  
\code
#ifdef VISP_HAVE_JPEG
  vpImageIo::write(I, "./rendered_image.jpg");
#endif
\endcode

Finally, as in \ref tutorial-getting-started we open a window to display the rendered image.

Note that this planar image projection capability has been also introduced in vpVirtualGrabber class exploited in tutorial-ibvs-4pts-image-tracking.cpp. Thus the next \ref tutorial-ibvs shows how to use it in order to introduce an image processing that does the tracking of the target during a visual-servo simulation.

*/
