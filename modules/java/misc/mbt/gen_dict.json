{
  "module_imports": [
    "java.lang.String"
  ],
  "class_ignore_list": [
    "vpMbDepthNormalTracker",
    "vpMbKltTracker",
    "vpMbScanLine",
    "vpMbTracker",
    "vpMbtDistanceCylinder",
    "vpMbtMeEllipse"
  ],
  "ManualFuncs": {
    "VpMbGenericTracker": {
      "VpMbGenericTracker" : {
        "j_code" : [
          "//",
          "// manual port",
          "// C++: vpMbGenericTracker()",
          "//\n",
          "//javadoc: VpMbGenericTracker::VpMbGenericTracker()\n",
          "public VpMbGenericTracker()",
          "{\n",
          "    nativeObj = VpMbGenericTracker_0();\n",
          "    return;",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: vpMbGenericTracker(unsigned int nbCameras, int trackerType = EDGE_TRACKER)",
          "//\n",
          "//javadoc: VpMbGenericTracker::VpMbGenericTracker()\n",
          "public VpMbGenericTracker(int nbCameras, int trackerType)",
          "{\n",
          "    nativeObj = VpMbGenericTracker_1(nbCameras, trackerType);\n",
          "    return;",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: vpMbGenericTracker(const std::vector<int> &trackerTypes)",
          "//\n",
          "//javadoc: VpMbGenericTracker::VpMbGenericTracker()\n",
          "public VpMbGenericTracker(int[] trackerTypes)",
          "{\n",
          "    nativeObj = VpMbGenericTracker_2(trackerTypes);\n",
          "    return;",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: vpMbGenericTracker(const std::vector<std::string> &cameraNames, const std::vector<int> &trackerTypes)",
          "//\n",
          "//javadoc: VpMbGenericTracker::VpMbGenericTracker()\n",
          "public VpMbGenericTracker(String[] cameraNames, int[] trackerTypes)",
          "{\n",
          "    nativeObj = VpMbGenericTracker_3(cameraNames, trackerTypes);\n",
          "    return;",
          "}"
        ],
        "cpp_code" : [
          "//",
          "// manual port",
          "// vpMbGenericTracker()",
          "//\n\n",
          "JNIEXPORT jlong JNICALL Java_org_visp_mbt_VpMbGenericTracker_VpMbGenericTracker_10 (JNIEnv*, jclass);\n",
          "JNIEXPORT jlong JNICALL Java_org_visp_mbt_VpMbGenericTracker_VpMbGenericTracker_10",
          "  (JNIEnv* env, jclass )",
          "{",
          "  static const char method_name[] = \"mbt::VpMbGenericTracker_10()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);\n",
          "    vpMbGenericTracker *_retval_ = new vpMbGenericTracker();",
          "    return (jlong) _retval_;",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "  return 0;",
          "}\n\n",
          "//",
          "// manual port",
          "// vpMbGenericTracker(unsigned int nbCameras, int trackerType = EDGE_TRACKER)",
          "//\n\n",
          "JNIEXPORT jlong JNICALL Java_org_visp_mbt_VpMbGenericTracker_VpMbGenericTracker_11 (JNIEnv*, jclass, jint, jint);\n",
          "JNIEXPORT jlong JNICALL Java_org_visp_mbt_VpMbGenericTracker_VpMbGenericTracker_11",
          "  (JNIEnv* env, jclass , jint nbCameras, jint trackerType)",
          "{",
          "  static const char method_name[] = \"mbt::VpMbGenericTracker_11()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* _retval_ = new vpMbGenericTracker( (int)nbCameras, (int)trackerType );",
          "    return (jlong) _retval_;",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "  return 0;",
          "}\n\n",
          "//",
          "// manual port",
          "// vpMbGenericTracker(const std::vector<int> &trackerTypes)",
          "//\n\n",
          "JNIEXPORT jlong JNICALL Java_org_visp_mbt_VpMbGenericTracker_VpMbGenericTracker_12 (JNIEnv*, jclass, jintArray);\n",
          "JNIEXPORT jlong JNICALL Java_org_visp_mbt_VpMbGenericTracker_VpMbGenericTracker_12",
          "  (JNIEnv* env, jclass , jintArray trackerTypes)",
          "{",
          "  static const char method_name[] = \"mbt::VpMbGenericTracker_12()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);\n",
          "    vpMbGenericTracker *_retval_ = new vpMbGenericTracker(List_to_vector_int(env, trackerTypes));",
          "    return (jlong) _retval_;",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "  return 0;",
          "}\n\n",
          "//",
          "// manual port",
          "// vpMbGenericTracker(const std::vector<std::string> &cameraNames, const std::vector<int> &trackerTypes)",
          "//\n\n",
          "JNIEXPORT jlong JNICALL Java_org_visp_mbt_VpMbGenericTracker_VpMbGenericTracker_13 (JNIEnv*, jclass, jobjectArray, jintArray);\n",
          "JNIEXPORT jlong JNICALL Java_org_visp_mbt_VpMbGenericTracker_VpMbGenericTracker_13",
          "  (JNIEnv* env, jclass , jobjectArray cameraNames, jintArray trackerTypes)",
          "{",
          "  static const char method_name[] = \"mbt::VpMbGenericTracker_13()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);\n",
          "    vpMbGenericTracker *_retval_ = new vpMbGenericTracker(array_string_to_vector(env, cameraNames), List_to_vector_int(env, trackerTypes));",
          "    return (jlong) _retval_;",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "  return 0;",
          "}"
        ],
        "jn_code" : [
          "// C++: void vpMbGenericTracker()",
          "private static native long VpMbGenericTracker_0();\n",
          "// C++: void vpMbGenericTracker(unsigned int nbCameras, int trackerType = EDGE_TRACKER)",
          "private static native long VpMbGenericTracker_1(int nbCameras, int trackerType);\n",
          "// C++: void vpMbGenericTracker(const std::vector<int> &trackerTypes)",
          "private static native long VpMbGenericTracker_2(int[] trackerTypes);\n",
          "// C++: void vpMbGenericTracker(const std::vector<std::string> &cameraNames, const std::vector<int> &trackerTypes)",
          "private static native long VpMbGenericTracker_3(String[] cameraNames, int[] trackerTypes);"
        ]
      },
      "getCameraParameters": {
        "j_code": [
          "//",
          "// manual port",
          "// C++: void getCameraParameters(vpCameraParameters camera)",
          "//",
          "//javadoc: VpMbGenericTracker::getCameraParameters()\n",
          "public void getCameraParameters(org.visp.core.VpCameraParameters camera)",
          "{",
          "   getCameraParameters_0(nativeObj, camera.nativeObj);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void getCameraParameters(vpCameraParameters cam1, vpCameraParameters cam2)",
          "//",
          "//javadoc: VpMbGenericTracker::getCameraParameters()\n",
          "public void getCameraParameters(org.visp.core.VpCameraParameters cam1, org.visp.core.VpCameraParameters cam2)",
          "{",
          "   getCameraParameters_1(nativeObj, cam1.nativeObj, cam2.nativeObj);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void getCameraParameters(mapOfCameraParameters)",
          "//",
          "//javadoc: VpMbGenericTracker::getCameraParameters()\n",
          "public void getCameraParameters(String[] cameraNames, org.visp.core.VpCameraParameters[] cameras)",
          "{",
          "   getCameraParameters_2(nativeObj, cameraNames, org.visp.utils.Converters.array_vpCameraParameters_to_array_native(cameras));",
          "}"
        ],
        "cpp_code": [
          "//",
          "// manual port",
          "// void getCameraParameters()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getCameraParameters_10 (JNIEnv*, jclass, jlong, jlong);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getCameraParameters_10",
          "  (JNIEnv* env, jclass , jlong self, jlong camera_nativeObj)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::getCameraParameters_10()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    vpCameraParameters& camera = *((vpCameraParameters*)camera_nativeObj);",
          "    me->getCameraParameters( camera );",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void getCameraParameters()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getCameraParameters_11 (JNIEnv*, jclass, jlong, jlong, jlong);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getCameraParameters_11",
          "  (JNIEnv* env, jclass , jlong self, jlong cam1_nativeObj, jlong cam2_nativeObj)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::getCameraParameters_11()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    vpCameraParameters& cam1 = *((vpCameraParameters*)cam1_nativeObj);",
          "    vpCameraParameters& cam2 = *((vpCameraParameters*)cam2_nativeObj);",
          "    me->getCameraParameters( cam1, cam2 );",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void getCameraParameters()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getCameraParameters_12 (JNIEnv*, jclass, jlong, jobjectArray, jlongArray);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getCameraParameters_12",
          "  (JNIEnv* env, jclass , jlong self, jobjectArray cameraNames, jlongArray cameras)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::getCameraParameters_12()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    int cameraCount = env->GetArrayLength(cameraNames);",
          "    std::map<std::string, vpCameraParameters> mapOfCameraParameters;",
          "    jlong *jcameras = env->GetLongArrayElements(cameras, 0);",
          "    for (int i = 0; i < cameraCount; i++) {",
          "      jstring key = (jstring) (env->GetObjectArrayElement(cameraNames, i));",
          "      vpCameraParameters& camera = (*(vpCameraParameters*)jcameras[i]);",
          "      mapOfCameraParameters[convertTo(env, key)] = camera;",
          "    }",
          "    me->getCameraParameters(mapOfCameraParameters);",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}"
        ],
        "jn_code": [
          "// C++: void getCameraParameters(vpCameraParameters camera)",
          "private static native void getCameraParameters_0(long address, long camera_nativeObj);\n",
          "// C++: void getCameraParameters(vpCameraParameters cam1, vpCameraParameters cam2)",
          "private static native void getCameraParameters_1(long address, long cam1_nativeObj, long cam2_nativeObj);\n",
          "// C++: void getCameraParameters(mapOfCameraParameters)",
          "private static native void getCameraParameters_2(long address, String[] cameraNames, long[] cameras);"
        ]
      },
      "getPose": {
        "j_code": [
          "//",
          "// manual port",
          "// C++: void getPose(vpHomogeneousMatrix cMo)",
          "//",
          "//javadoc: VpMbGenericTracker::getPose()\n",
          "public void getPose(org.visp.core.VpHomogeneousMatrix cMo)",
          "{",
          "   getPose_0(nativeObj, cMo.nativeObj);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void getPose(vpHomogeneousMatrix c1Mo, vpHomogeneousMatrix c2Mo)",
          "//",
          "//javadoc: VpMbGenericTracker::getPose()\n",
          "public void getPose(org.visp.core.VpHomogeneousMatrix c1Mo, org.visp.core.VpHomogeneousMatrix c2Mo)",
          "{",
          "   getPose_1(nativeObj, c1Mo.nativeObj, c2Mo.nativeObj);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void getPose(mapOfCameraPoses)",
          "//",
          "//javadoc: VpMbGenericTracker::getPose()\n",
          "public void getPose(String[] cameraNames, org.visp.core.VpHomogeneousMatrix[] poses)",
          "{",
          "   getPose_2(nativeObj, cameraNames, org.visp.utils.Converters.array_vpHomogeneousMatrix_to_array_native(poses));",
          "}"
        ],
        "cpp_code": [
          "//",
          "// manual port",
          "// void getPose()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getPose_10 (JNIEnv*, jclass, jlong, jlong);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getPose_10",
          "  (JNIEnv* env, jclass , jlong self, jlong cMo_nativeObj)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::getPose_10()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    vpHomogeneousMatrix& cMo = *((vpHomogeneousMatrix*)cMo_nativeObj);",
          "    me->getPose( cMo );",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void getPose()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getPose_11 (JNIEnv*, jclass, jlong, jlong, jlong);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getPose_11",
          "  (JNIEnv* env, jclass , jlong self, jlong c1Mo_nativeObj, jlong c2Mo_nativeObj)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::getPose_11()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    vpHomogeneousMatrix& c1Mo = *((vpHomogeneousMatrix*)c1Mo_nativeObj);",
          "    vpHomogeneousMatrix& c2Mo = *((vpHomogeneousMatrix*)c2Mo_nativeObj);",
          "    me->getPose( c1Mo, c2Mo );",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void getPose()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getPose_12 (JNIEnv*, jclass, jlong, jobjectArray, jlongArray);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_getPose_12",
          "  (JNIEnv* env, jclass , jlong self, jobjectArray cameraNames, jlongArray poses)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::getPose_12()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    int cameraCount = env->GetArrayLength(cameraNames);",
          "    std::map<std::string, vpHomogeneousMatrix> mapOfCameraPoses;",
          "    jlong *jposes = env->GetLongArrayElements(poses, 0);",
          "    for (int i = 0; i < cameraCount; i++) {",
          "      jstring key = (jstring) (env->GetObjectArrayElement(cameraNames, i));",
          "      vpHomogeneousMatrix& cMo = (*(vpHomogeneousMatrix*)jposes[i]);",
          "      mapOfCameraPoses[convertTo(env, key)] = cMo;",
          "    }",
          "    me->getPose(mapOfCameraPoses);",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}"
        ],
        "jn_code": [
          "// C++: void getPose(vpHomogeneousMatrix cMo)",
          "private static native void getPose_0(long address, long cMo_nativeObj);\n",
          "// C++: void getPose(vpHomogeneousMatrix c1Mo, vpHomogeneousMatrix c2Mo)",
          "private static native void getPose_1(long address, long c1Mo_nativeObj, long c2Mo_nativeObj);\n",
          "// C++: void getPose(mapOfCameraPoses)",
          "private static native void getPose_2(long address, String[] cameraNames, long[] poses);"
        ]
      },
      "initFromPose": {
        "j_code": [
          "//",
          "// manual port",
          "// C++: void initFromPose(vpImage_char I, vpHomogeneousMatrix cMo)",
          "//",
          "//javadoc: VpMbGenericTracker::initFromPose()\n",
          "public void initFromPose(org.visp.core.VpImageUChar I, org.visp.core.VpHomogeneousMatrix cMo)",
          "{",
          "   initFromPose_0(nativeObj, I.nativeObj, cMo.nativeObj);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void initFromPose(vpImage_char I1, vpImage_char I2, vpHomogeneousMatrix c1Mo, vpHomogeneousMatrix c2Mo)",
          "//",
          "//javadoc: VpMbGenericTracker::initFromPose()\n",
          "public void initFromPose(org.visp.core.VpImageUChar I1, org.visp.core.VpImageUChar I2, org.visp.core.VpHomogeneousMatrix cMo1, org.visp.core.VpHomogeneousMatrix cMo2)",
          "{",
          "   initFromPose_1(nativeObj, I1.nativeObj, I2.nativeObj, cMo1.nativeObj, cMo2.nativeObj);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void initFromPose(mapOfImages, mapOfCameraPoses)",
          "//",
          "//javadoc: VpMbGenericTracker::initFromPose()\n",
          "public void initFromPose(String[] cameraNames, org.visp.core.VpImageUChar[] I, org.visp.core.VpHomogeneousMatrix[] cMo)",
          "{",
          "   initFromPose_2(nativeObj, cameraNames, org.visp.utils.Converters.array_vpImageUChar_to_array_native(I), org.visp.utils.Converters.array_vpHomogeneousMatrix_to_array_native(cMo));",
          "}"
        ],
        "cpp_code": [
          "//",
          "// manual port",
          "// void initFromPose()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_initFromPose_10 (JNIEnv*, jclass, jlong, jlong, jlong);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_initFromPose_10",
          "  (JNIEnv* env, jclass , jlong self, jlong I_nativeObj, jlong cMo_nativeObj)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::initFromPose_10()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    vpImage<unsigned char>& I = *((vpImage<unsigned char>*)I_nativeObj);",
          "    vpHomogeneousMatrix& cMo = *((vpHomogeneousMatrix*)cMo_nativeObj);",
          "    me->initFromPose( I, cMo );",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void initFromPose()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_initFromPose_11 (JNIEnv*, jclass, jlong, jlong, jlong, jlong, jlong);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_initFromPose_11",
          "  (JNIEnv* env, jclass , jlong self, jlong I1_nativeObj, jlong I2_nativeObj, jlong c1Mo_nativeObj, jlong c2Mo_nativeObj)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::initFromPose_11()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    vpImage<unsigned char>& I1 = *((vpImage<unsigned char>*)I1_nativeObj);",
          "    vpImage<unsigned char>& I2 = *((vpImage<unsigned char>*)I2_nativeObj);",
          "    vpHomogeneousMatrix& c1Mo = *((vpHomogeneousMatrix*)c1Mo_nativeObj);",
          "    vpHomogeneousMatrix& c2Mo = *((vpHomogeneousMatrix*)c2Mo_nativeObj);",
          "    me->initFromPose( I1, I2, c1Mo, c2Mo );",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void initFromPose()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_initFromPose_12 (JNIEnv*, jclass, jlong, jobjectArray, jlongArray, jlongArray);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_initFromPose_12",
          "  (JNIEnv* env, jclass , jlong address, jobjectArray cameraNames, jlongArray images, jlongArray poses)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::initFromPose_12()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* tracker = (vpMbGenericTracker*) address; //TODO: check for NULL",
          "    int stringCount = env->GetArrayLength(cameraNames);",
          "    std::map<std::string, const vpImage<unsigned char> *> mapOfImages;",
          "    std::map<std::string, vpHomogeneousMatrix> mapOfCameraPoses;",
          "    jlong *jimages = env->GetLongArrayElements(images, 0);",
          "    jlong *jposes = env->GetLongArrayElements(poses, 0);",
          "    for (int i = 0; i < stringCount; i++) {",
          "      jstring key = (jstring) (env->GetObjectArrayElement(cameraNames, i));",
          "      std::string cameraName = convertTo(env, key);",
          "      const vpImage<unsigned char>* I = (vpImage<unsigned char>*)jimages[i];",
          "      mapOfImages[cameraName] = I;",
          "      vpHomogeneousMatrix& cMo = (*(vpHomogeneousMatrix*)jposes[i]);",
          "      mapOfCameraPoses[cameraName] = cMo;",
          "    }",
          "    tracker->initFromPose(mapOfImages, mapOfCameraPoses);",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}"
        ],
        "jn_code": [
          "// C++: void initFromPose(vpImage_char I, vpHomogeneousMatrix cMo)",
          "private static native void initFromPose_0(long address, long I_nativeObj, long cMo_nativeObj);\n",
          "// C++: void initFromPose(vpImage_char I1, vpImage_char I2, vpHomogeneousMatrix c1Mo, vpHomogeneousMatrix c2Mo)",
          "private static native void initFromPose_1(long address, long I1_nativeObj, long I2_nativeObj, long cMo1_nativeObj, long cMo2_nativeObj);\n",
          "// C++: void initFromPose(mapOfImages, mapOfCameraPoses)",
          "private static native void initFromPose_2(long address, String[] cameraNames, long[] images, long[] poses);"
        ]
      },
      "loadConfigFile": {
        "j_code": [
          "//",
          "// manual port",
          "// C++: void loadConfigFile(string configFile)",
          "//",
          "//javadoc: VpMbGenericTracker::loadConfigFile()\n",
          "public void loadConfigFile(String configFile)",
          "{",
          "   loadConfigFile_0(nativeObj, configFile);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void loadConfigFile(string configFile1, string configFile2)",
          "//",
          "//javadoc: VpMbGenericTracker::loadConfigFile()\n",
          "public void loadConfigFile(String configFile1, String configFile2)",
          "{",
          "   loadConfigFile_1(nativeObj, configFile1, configFile2);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void loadConfigFile(const std::map<std::string, std::string>& map)",
          "//",
          "//javadoc: VpMbGenericTracker::loadConfigFile()\n",
          "public void loadConfigFile(String[] cameraNames, String[] configFiles)",
          "{",
          "   loadConfigFile_2(nativeObj, cameraNames, configFiles);",
          "}"
        ],
        "cpp_code": [
          "//",
          "// manual port",
          "// void loadConfigFile()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadConfigFile_10 (JNIEnv*, jclass, jlong, jstring);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadConfigFile_10",
          "  (JNIEnv* env, jclass , jlong self, jstring configFile)",
          "{",
          "   static const char method_name[] = \"mbt::loadConfigFile_11()\";",
          "   try {",
          "     LOGD(\"%s\", method_name);",
          "     vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "     const char* utf_configFile = env->GetStringUTFChars(configFile, 0);",
          "     string n_configFile( utf_configFile ? utf_configFile : \"\" );",
          "     env->ReleaseStringUTFChars(configFile, utf_configFile);",
          "     me->loadConfigFile( n_configFile );",
          "   } catch(const std::exception &e) {",
          "     throwJavaException(env, &e, method_name);",
          "   } catch (...) {",
          "     throwJavaException(env, 0, method_name);",
          "   }",
          "}\n\n",
          "//",
          "// manual port",
          "// void loadConfigFile()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadConfigFile_11 (JNIEnv*, jclass, jlong, jstring, jstring);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadConfigFile_11",
          "  (JNIEnv* env, jclass , jlong self, jstring configFile1, jstring configFile2)",
          "{",
          "   static const char method_name[] = \"mbt::loadConfigFile_10()\";",
          "   try {",
          "     LOGD(\"%s\", method_name);",
          "     vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "     const char* utf_configFile1 = env->GetStringUTFChars(configFile1, 0);",
          "     string n_configFile1( utf_configFile1 ? utf_configFile1 : \"\" );",
          "     env->ReleaseStringUTFChars(configFile1, utf_configFile1);",
          "     const char* utf_configFile2 = env->GetStringUTFChars(configFile2, 0);",
          "     string n_configFile2( utf_configFile2 ? utf_configFile2 : \"\" );",
          "     env->ReleaseStringUTFChars(configFile2, utf_configFile2);",
          "     me->loadConfigFile( n_configFile1, n_configFile2 );",
          "   } catch(const std::exception &e) {",
          "     throwJavaException(env, &e, method_name);",
          "   } catch (...) {",
          "     throwJavaException(env, 0, method_name);",
          "   }",
          "}\n\n",
          "//",
          "// manual port",
          "// void loadConfigFile()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadConfigFile_12 (JNIEnv*, jclass, jlong, jobjectArray, jobjectArray);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadConfigFile_12",
          "  (JNIEnv* env, jclass , jlong address, jobjectArray stringKeys, jobjectArray stringValues)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::loadConfigFile()\";",
          "  try {",
          "   LOGD(\"%s\", method_name);",
          "   vpMbGenericTracker *tracker = (vpMbGenericTracker*) address;",
          "   int stringCount = env->GetArrayLength(stringKeys);",
          "   std::map<std::string, std::string> map;",
          "   for (int i = 0; i < stringCount; i++) {",
          "     jstring key = (jstring) (env->GetObjectArrayElement(stringKeys, i));",
          "     jstring value = (jstring) (env->GetObjectArrayElement(stringValues, i));",
          "     map[convertTo(env, key)] = convertTo(env, value);",
          "   }",
          "   tracker->loadConfigFile(map);",
          "  } catch(const std::exception &e) {",
          "   throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "   throwJavaException(env, 0, method_name);",
          "  }",
          "}"
        ],
        "jn_code": [
          "// C++: void loadConfigFile(string configFile)",
          "private static native void loadConfigFile_0(long address, String configFile);\n",
          "// C++: void loadConfigFile(string configFile1, string configFile2)",
          "private static native void loadConfigFile_1(long address, String configFile1, String configFile2);\n",
          "// C++: void loadConfigFile(const std::map<std::string, std::string>& map)",
          "private static native void loadConfigFile_2(long address, String[] cameraNames, String[] configFiles);"
        ]
      },
      "loadModel": {
        "j_code": [
          "//",
          "// manual port",
          "// C++: void loadModel(string modelFile, bool verbose = false, vpHomogeneousMatrix T = vpHomogeneousMatrix())",
          "//",
          "//javadoc: VpMbGenericTracker::loadModel()\n",
          "public void loadModel(String modelFile, boolean verbose, org.visp.core.VpHomogeneousMatrix T)",
          "{",
          "   loadModel_0(nativeObj, modelFile, verbose, T.nativeObj);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void loadModel(string modelFile)",
          "//",
          "//javadoc: VpMbGenericTracker::loadModel()\n",
          "public void loadModel(String modelFile)",
          "{",
          "   loadModel_1(nativeObj, modelFile);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void loadModel(string modelFile1, string modelFile2, bool verbose = false, vpHomogeneousMatrix T1 = vpHomogeneousMatrix(), vpHomogeneousMatrix T2 = vpHomogeneousMatrix())",
          "//",
          "//javadoc: VpMbGenericTracker::loadModel()\n",
          "public void loadModel(String modelFile1, String modelFile2, boolean verbose, org.visp.core.VpHomogeneousMatrix T1, org.visp.core.VpHomogeneousMatrix T2)",
          "{",
          "   loadModel_2(nativeObj, modelFile1, modelFile2, verbose, T1.nativeObj, T2.nativeObj);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void loadModel(string modelFile1, string modelFile2)",
          "//",
          "//javadoc: VpMbGenericTracker::loadModel()\n",
          "public void loadModel(String modelFile1, String modelFile2)",
          "{",
          "   loadModel_3(nativeObj, modelFile1, modelFile2);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void loadModel(const std::map<std::string, std::string>& map, bool verbose, const std::map<std::string, vpHomogeneousMatrix> &mapOfT)",
          "//",
          "//javadoc: VpMbGenericTracker::loadModel()\n",
          "public void loadModel(String[] cameraNames, String[] modelFiles, boolean verbose, org.visp.core.VpHomogeneousMatrix[] Ts)",
          "{",
          "   loadModel_4(nativeObj, cameraNames, modelFiles, verbose, org.visp.utils.Converters.array_vpHomogeneousMatrix_to_array_native(Ts));",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void loadModel(const std::map<std::string, std::string>& map)",
          "//",
          "//javadoc: VpMbGenericTracker::loadModel()\n",
          "public void loadModel(String[] cameraNames, String[] modelFiles)",
          "{",
          "   loadModel_5(nativeObj, cameraNames, modelFiles);",
          "}"
        ],
        "cpp_code": [
          "//",
          "// manual port",
          "// void loadModel()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_10 (JNIEnv*, jclass, jlong, jstring, jboolean, jlong);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_10",
          "  (JNIEnv* env, jclass , jlong self, jstring modelFile, jboolean verbose, jlong T_nativeObj)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::loadModel()\";",
          "   try {",
          "     LOGD(\"%s\", method_name);",
          "     vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "     const char* utf_modelFile = env->GetStringUTFChars(modelFile, 0);",
          "     string n_modelFile( utf_modelFile ? utf_modelFile : \"\" );",
          "     env->ReleaseStringUTFChars(modelFile, utf_modelFile);",
          "     vpHomogeneousMatrix& T = *((vpHomogeneousMatrix*)T_nativeObj);",
          "     me->loadModel( n_modelFile, (bool)verbose, T );",
          "   } catch(const std::exception &e) {",
          "     throwJavaException(env, &e, method_name);",
          "   } catch (...) {",
          "     throwJavaException(env, 0, method_name);",
          "   }",
          "}\n\n",
          "//",
          "// manual port",
          "// void loadModel()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_11 (JNIEnv*, jclass, jlong, jstring);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_11",
          "  (JNIEnv* env, jclass , jlong self, jstring modelFile)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::loadModel()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    const char* utf_modelFile = env->GetStringUTFChars(modelFile, 0);",
          "    string n_modelFile( utf_modelFile ? utf_modelFile : \"\" );",
          "    env->ReleaseStringUTFChars(modelFile, utf_modelFile);",
          "    me->loadModel( n_modelFile );",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void loadModel()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_12 (JNIEnv*, jclass, jlong, jstring, jstring, jboolean, jlong, jlong);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_12",
          "  (JNIEnv* env, jclass , jlong self, jstring modelFile1, jstring modelFile2, jboolean verbose, jlong T1_nativeObj, jlong T2_nativeObj)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::loadModel()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    const char* utf_modelFile1 = env->GetStringUTFChars(modelFile1, 0);",
          "    string n_modelFile1( utf_modelFile1 ? utf_modelFile1 : \"\" );",
          "    env->ReleaseStringUTFChars(modelFile1, utf_modelFile1);",
          "    const char* utf_modelFile2 = env->GetStringUTFChars(modelFile2, 0);",
          "    string n_modelFile2( utf_modelFile2 ? utf_modelFile2 : \"\" );",
          "    env->ReleaseStringUTFChars(modelFile2, utf_modelFile2);",
          "    vpHomogeneousMatrix& T1 = *((vpHomogeneousMatrix*)T1_nativeObj);",
          "    vpHomogeneousMatrix& T2 = *((vpHomogeneousMatrix*)T2_nativeObj);",
          "    me->loadModel( n_modelFile1, n_modelFile2, (bool)verbose, T1, T2 );",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void loadModel()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_13 (JNIEnv*, jclass, jlong, jstring, jstring);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_13",
          "  (JNIEnv* env, jclass , jlong self, jstring modelFile1, jstring modelFile2)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::loadModel()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    const char* utf_modelFile1 = env->GetStringUTFChars(modelFile1, 0);",
          "    string n_modelFile1( utf_modelFile1 ? utf_modelFile1 : \"\" );",
          "    env->ReleaseStringUTFChars(modelFile1, utf_modelFile1);",
          "    const char* utf_modelFile2 = env->GetStringUTFChars(modelFile2, 0);",
          "    string n_modelFile2( utf_modelFile2 ? utf_modelFile2 : \"\" );",
          "    env->ReleaseStringUTFChars(modelFile2, utf_modelFile2);",
          "    me->loadModel( n_modelFile1, n_modelFile2 );",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void loadModel()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_14 (JNIEnv*, jclass, jlong, jobjectArray, jobjectArray, jboolean, jlongArray);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_14",
          "  (JNIEnv* env, jclass , jlong address, jobjectArray stringKeys, jobjectArray stringValues, jboolean verbose, jlongArray Ts)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::loadModel()\";",
          "  try {",
          "   LOGD(\"%s\", method_name);",
          "   vpMbGenericTracker *tracker = (vpMbGenericTracker*) address;",
          "   int stringCount = env->GetArrayLength(stringKeys);",
          "   int sizeT = env->GetArrayLength(Ts);",
          "   jlong *jTs = sizeT > 0 ? env->GetLongArrayElements(Ts, 0) : NULL;",
          "   std::map<std::string, std::string> map;",
          "   std::map<std::string, vpHomogeneousMatrix> mapOfT;",
          "   for (int i = 0; i < stringCount; i++) {",
          "     jstring key = (jstring) (env->GetObjectArrayElement(stringKeys, i));",
          "     jstring value = (jstring) (env->GetObjectArrayElement(stringValues, i));",
          "     map[convertTo(env, key)] = convertTo(env, value);",
          "     if (jTs != NULL) {",
          "       vpHomogeneousMatrix& T = *((vpHomogeneousMatrix*)jTs[i]);",
          "       mapOfT[convertTo(env, key)] = T;",
          "     }",
          "   }",
          "   tracker->loadModel(map, verbose, mapOfT);",
          "  } catch(const std::exception &e) {",
          "   throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "   throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void loadModel()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_15 (JNIEnv*, jclass, jlong, jobjectArray, jobjectArray);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_loadModel_15",
          "  (JNIEnv* env, jclass , jlong address, jobjectArray stringKeys, jobjectArray stringValues)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::loadModel()\";",
          "  try {",
          "   LOGD(\"%s\", method_name);",
          "   vpMbGenericTracker *tracker = (vpMbGenericTracker*) address;",
          "   int stringCount = env->GetArrayLength(stringKeys);",
          "   std::map<std::string, std::string> map;",
          "   for (int i = 0; i < stringCount; i++) {",
          "     jstring key = (jstring) (env->GetObjectArrayElement(stringKeys, i));",
          "     jstring value = (jstring) (env->GetObjectArrayElement(stringValues, i));",
          "     map[convertTo(env, key)] = convertTo(env, value);",
          "   }",
          "   tracker->loadModel(map);",
          "  } catch(const std::exception &e) {",
          "   throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "   throwJavaException(env, 0, method_name);",
          "  }",
          "}"
        ],
        "jn_code": [
          "// C++: void loadModel(string modelFile, bool verbose = false, vpHomogeneousMatrix T = vpHomogeneousMatrix())",
          "private static native void loadModel_0(long address, String modelFile, boolean verbose, long T_nativeObj);\n",
          "// C++: void loadModel(string modelFile)",
          "private static native void loadModel_1(long address, String modelFile);\n",
          "// C++: void loadModel(string modelFile1, string modelFile2, bool verbose = false, vpHomogeneousMatrix T1 = vpHomogeneousMatrix(), vpHomogeneousMatrix T2 = vpHomogeneousMatrix())",
          "private static native void loadModel_2(long address, String modelFile1, String modelFile2, boolean verbose, long T1_nativeObj, long T2_nativeObj);\n",
          "// C++: void loadModel(string modelFile1, string modelFile2)",
          "private static native void loadModel_3(long address, String modelFile1, String modelFile2);\n",
          "// C++: void loadModel(const std::map<std::string, std::string>& map, bool verbose, const std::map<std::string, vpHomogeneousMatrix> &mapOfT)",
          "private static native void loadModel_4(long address, String[] cameraNames, String[] modelFiles, boolean verbose, long[] Ts);\n",
          "// C++: void loadModel(const std::map<std::string, std::string>& map, bool verbose, const std::map<std::string, vpHomogeneousMatrix> &mapOfT)",
          "private static native void loadModel_5(long address, String[] cameraNames, String[] modelFiles);"
        ]
      },
      "track": {
        "j_code": [
          "//",
          "// manual port",
          "// C++: void track(vpImage_char I)",
          "//",
          "//javadoc: VpMbGenericTracker::track()\n",
          "public void track(org.visp.core.VpImageUChar I)",
          "{",
          "   track_0(nativeObj, I.nativeObj);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void track(vpImage_char I1, vpImage_char I2)",
          "//",
          "//javadoc: VpMbGenericTracker::track()\n",
          "public void track(org.visp.core.VpImageUChar I1, org.visp.core.VpImageUChar I2)",
          "{",
          "   track_1(nativeObj, I1.nativeObj, I2.nativeObj);",
          "}\n\n",
          "//",
          "// manual port",
          "// C++: void track(mapOfImages, mapOfPointClouds, mapOfPointCloudWidths, mapOfPointCloudHeights)",
          "//",
          "//javadoc: VpMbGenericTracker::track()\n",
          "public void track(String[] cameraNames, org.visp.core.VpImageUChar[] images, String[] depthNames, org.visp.core.VpColVector[][] pointclouds, int[] pointcloudWidths, int[] pointcloudHeights)",
          "{",
          "   track_2(nativeObj, cameraNames, org.visp.utils.Converters.array_vpImageUChar_to_array_native(images), depthNames, org.visp.utils.Converters.matrix_vpColVector_to_matrix_native(pointclouds), pointcloudWidths, pointcloudHeights);",
          "}\n\n"
        ],
        "cpp_code": [
          "//",
          "// manual port",
          "// void track()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_track_10 (JNIEnv*, jclass, jlong, jlong);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_track_10",
          "  (JNIEnv* env, jclass , jlong self, jlong I_nativeObj)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::track_10()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    vpImage<unsigned char>& I = *((vpImage<unsigned char>*)I_nativeObj);",
          "    me->track( I );",
          "    return;",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void track()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_track_11 (JNIEnv*, jclass, jlong, jlong, jlong);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_track_11",
          "  (JNIEnv* env, jclass , jlong self, jlong I1_nativeObj, jlong I2_nativeObj)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::track_11()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* me = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    vpImage<unsigned char>& I1 = *((vpImage<unsigned char>*)I1_nativeObj);",
          "    vpImage<unsigned char>& I2 = *((vpImage<unsigned char>*)I2_nativeObj);",
          "    me->track( I1, I2 );",
          "    return;",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}\n\n",
          "//",
          "// manual port",
          "// void track()",
          "//\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_track_12 (JNIEnv*, jclass, jlong, jobjectArray, jlongArray, jobjectArray, jobjectArray, jintArray, jintArray);\n",
          "JNIEXPORT void JNICALL Java_org_visp_mbt_VpMbGenericTracker_track_12",
          "  (JNIEnv* env, jclass , jlong self, jobjectArray cameraNames, jlongArray images, jobjectArray depthNames, jobjectArray pointclouds, jintArray pointcloudWidths, jintArray pointcloudHeights)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::track_12()\";",
          "  try {",
          "    LOGD(\"%s\", method_name);",
          "    vpMbGenericTracker* tracker = (vpMbGenericTracker*) self; //TODO: check for NULL",
          "    int cameraNamesCount = env->GetArrayLength(cameraNames);",
          "    jlong *jlong_images = env->GetLongArrayElements(images, 0);",
          "    std::map<std::string, const vpImage<unsigned char> *> mapOfImages;",
          "    for (int i = 0; i < cameraNamesCount; i++) {",
          "      jstring key = (jstring) (env->GetObjectArrayElement(cameraNames, i));",
          "      const vpImage<unsigned char> *I = ((vpImage<unsigned char>*)jlong_images[i]);",
          "      mapOfImages[convertTo(env, key)] = I;",
          "    }",
          "    env->ReleaseLongArrayElements(images, jlong_images, JNI_ABORT);",
          "    int depthNamesCount = env->GetArrayLength(depthNames);",
          "    std::map<std::string, const std::vector<vpColVector> *> mapOfPointclouds;",
          "    std::map<std::string, std::vector<vpColVector> > mapOfPointclouds_noConst;",
          "    std::map<std::string, unsigned int> mapOfWidths, mapOfHeights;",
          "    jint* widths = env->GetIntArrayElements(pointcloudWidths, 0);",
          "    jint* heights = env->GetIntArrayElements(pointcloudHeights, 0);",
          "    for (int i = 0; i < depthNamesCount; i++) {",
          "      jstring key = (jstring) (env->GetObjectArrayElement(depthNames, i));",
          "      jlongArray values = (jlongArray) (env->GetObjectArrayElement(pointclouds, i));",
          "      int depthCount = env->GetArrayLength(values);",
          "      jboolean isCopy;",
          "      jlong* values_arr = (jlong*)env->GetPrimitiveArrayCritical(values, &isCopy);",
          "      env->ReleasePrimitiveArrayCritical(values, values_arr, JNI_ABORT);",
          "      std::string depthName = convertTo(env, key);",
          "      mapOfWidths[depthName] = (unsigned int)widths[i];",
          "      mapOfHeights[depthName] = (unsigned int)heights[i];",
          "      mapOfPointclouds_noConst[depthName].reserve(depthCount);",
          "      for (int j = 0; j < depthCount; j++) {",
          "        const vpColVector& ref = *((vpColVector*)values_arr[j]);",
          "        mapOfPointclouds_noConst[depthName].push_back(ref);",
          "      }",
          "      mapOfPointclouds[depthName] = &mapOfPointclouds_noConst[depthName];",
          "    }",
          "    env->ReleaseIntArrayElements(pointcloudWidths, widths, JNI_ABORT);",
          "    env->ReleaseIntArrayElements(pointcloudHeights, heights, JNI_ABORT);",
          "    tracker->track(mapOfImages, mapOfPointclouds, mapOfWidths, mapOfHeights);",
          "  } catch(const std::exception &e) {",
          "    throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "    throwJavaException(env, 0, method_name);",
          "  }",
          "}"
        ],
        "jn_code": [
          "// C++: void track(vpImage_char I)",
          "private static native void track_0(long address, long I_nativeObj);\n",
          "// C++: void track(vpImage_char I1, vpImage_char I2",
          "private static native void track_1(long address, long I1_nativeObj, long I2_nativeObj);\n",
          "// C++: void track(mapOfImages, mapOfPointClouds, mapOfPointCloudWidths, mapOfPointCloudHeights)",
          "private static native void track_2(long address, String[] cameraNames, long[] images, String[] depthNames, long[][] pointclouds, int[] pointcloudWidths, int[] pointcloudHeights);"
        ]
      },
      "getError": {
        "j_code": [
          ""
        ],
        "cpp_code": [
          ""
        ],
        "jn_code": [
          ""
        ]
      },
      "getRobustWeights": {
        "j_code": [
          ""
        ],
        "cpp_code": [
          ""
        ],
        "jn_code": [
          ""
        ]
      },
      "getClipping": {
        "j_code": [
          ""
        ],
        "cpp_code": [
          ""
        ],
        "jn_code": [
          ""
        ]
      },
      "setNbRayCastingAttemptsForVisibility": {
        "j_code": [
          ""
        ],
        "cpp_code": [
          ""
        ],
        "jn_code": [
          ""
        ]
      },
      "setGoodNbRayCastingAttemptsRatio": {
        "j_code": [
          ""
        ],
        "cpp_code": [
          ""
        ],
        "jn_code": [
          ""
        ]
      },
      "getKltNbPoints": {
        "j_code": [
          ""
        ],
        "cpp_code": [
          ""
        ],
        "jn_code": [
          ""
        ]
      },	
      "getKltMaskBorder": {
        "j_code": [
          ""
        ],
        "cpp_code": [
          ""
        ],
        "jn_code": [
          ""
        ]
      },	
      "setKltMaskBorder": {
        "j_code": [
          ""
        ],
        "cpp_code": [
          ""
        ],
        "jn_code": [
          ""
        ]
      },	
      "getKltThresholdAcceptation": {
        "j_code": [
          ""
        ],
        "cpp_code": [
          ""
        ],
        "jn_code": [
          ""
        ]
      },	
      "setKltThresholdAcceptation": {
        "j_code": [
          ""
        ],
        "cpp_code": [
          ""
        ],
        "jn_code": [
          ""
        ]
      },	
      "setUseKltTracking": {
        "j_code": [
          ""
        ],
        "cpp_code": [
          ""
        ],
        "jn_code": [
          ""
        ]
      },	
      "getModelForDisplay" : {
        "j_code" : [
          "//",
          "// manual port",
          "// C++: void getModelForDisplay(mapOfModels, mapOfwidths, mapOfheights, mapOfcMos, mapOfCams, boolean displayFullModel)",
          "//",
          "//javadoc: VpMbGenericTracker::getModelForDisplay()\n",
          "public double[][][] getModelForDisplay(String[] cameraNames, int[] widths, int[] heights, org.visp.core.VpHomogeneousMatrix[] cMos, org.visp.core.VpCameraParameters[] cams, boolean displayFullModel)",
          "{",
          "   return getModelForDisplay(nativeObj, cameraNames, widths, heights, org.visp.utils.Converters.array_vpHomogeneousMatrix_to_array_native(cMos), org.visp.utils.Converters.array_vpCameraParameters_to_array_native(cams), displayFullModel);",
          "}"
        ],
        "cpp_code" : [
          "//",
          "// manual port",
          "// void getModelForDisplay(mapOfModels, mapOfwidths, mapOfheights, mapOfcMos, mapOfCams, boolean displayFullModel)",
          "//\n",
          "JNIEXPORT jobjectArray JNICALL Java_org_visp_mbt_VpMbGenericTracker_getModelForDisplay (JNIEnv*, jclass, jlong, jobjectArray, jintArray, jintArray, jlongArray, jlongArray, jboolean);\n",
          "JNIEXPORT jobjectArray JNICALL Java_org_visp_mbt_VpMbGenericTracker_getModelForDisplay",
          "  (JNIEnv* env, jclass , jlong address, jobjectArray cameraNames, jintArray widths, jintArray heights, jlongArray cMos, jlongArray cams, jboolean displayFullModel)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::getModelForDisplay()\";",
          "  try {",
          "   LOGD(\"%s\", method_name);",
          "   vpMbGenericTracker *tracker = (vpMbGenericTracker*) address;",
          "   std::map<std::string, unsigned int> mapOfwidths;",
          "   std::map<std::string, unsigned int> mapOfheights;",
          "   std::map<std::string, vpHomogeneousMatrix> mapOfcMos;",
          "   std::map<std::string, vpCameraParameters> mapOfCams;",
          "   std::vector<std::string> keys = array_string_to_vector(env, cameraNames);",
          "   std::vector<int> widths_vec = List_to_vector_int(env, widths);",
          "   std::vector<int> heights_vec = List_to_vector_int(env, heights);",
          "   std::vector<vpHomogeneousMatrix> poses_vec = List_to_vector_vpHomogeneousMatrix(env, cMos);",
          "   std::vector<vpCameraParameters> cams_vec = List_to_vector_vpCameraParameters(env, cams);",
          "   for (size_t i = 0; i < keys.size(); i++) {",
          "     const std::string& key = keys[i];",
          "     mapOfwidths[key] = widths_vec[i];",
          "     mapOfheights[key] = heights_vec[i];",
          "     mapOfcMos[key] = poses_vec[i];",
          "     mapOfCams[key] = cams_vec[i];",
          "   }",
          "   std::map<std::string, std::vector<std::vector<double> > > mapOfModels;",
          "   tracker->getModelForDisplay(mapOfModels, mapOfwidths, mapOfheights, mapOfcMos, mapOfCams, (bool) displayFullModel);",
          "   return map_string_vector_vector_double_to_array_native(env, mapOfModels);",
          "  } catch(const std::exception &e) {",
          "   throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "   throwJavaException(env, 0, method_name);",
          "  }",
          "  return 0;",
          "}"
        ],
        "jn_code" : [
          "// C++: void getModelForDisplay(mapOfModels, mapOfwidths, mapOfheights, mapOfcMos, mapOfCams, boolean displayFullModel)",
          "private static native double[][][] getModelForDisplay(long address, String[] cameraNames, int[] widths, int[] heights, long[] cMos, long[] cams, boolean displayFullModel);"
        ]
      },
      "getFeaturesForDisplay" : {
        "j_code" : [
          "//",
          "// manual port",
          "// C++: void getFeaturesForDisplay(std::map<std::string, std::vector<std::vector<double> > > &mapOfFeatures)",
          "//",
          "//javadoc: VpMbGenericTracker::getFeaturesForDisplay()\n",
          "public double[][][] getFeaturesForDisplay()",
          "{",
          "   return getFeaturesForDisplay(nativeObj);",
          "}"
        ],
        "cpp_code" : [
          "//",
          "// manual port",
          "// void getFeaturesForDisplay(std::map<std::string, std::vector<std::vector<double> > > &mapOfFeatures)",
          "//\n",
          "JNIEXPORT jobjectArray JNICALL Java_org_visp_mbt_VpMbGenericTracker_getFeaturesForDisplay (JNIEnv*, jclass, jlong);\n",
          "JNIEXPORT jobjectArray JNICALL Java_org_visp_mbt_VpMbGenericTracker_getFeaturesForDisplay",
          "  (JNIEnv* env, jclass , jlong address)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::getFeaturesForDisplay()\";",
          "  try {",
          "   LOGD(\"%s\", method_name);",
          "   vpMbGenericTracker *tracker = (vpMbGenericTracker*) address;",
          "   std::map<std::string, std::vector<std::vector<double> > > mapOfFeatures;",
          "   tracker->getFeaturesForDisplay(mapOfFeatures);",
          "   return map_string_vector_vector_double_to_array_native(env, mapOfFeatures);",
          "  } catch(const std::exception &e) {",
          "   throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "   throwJavaException(env, 0, method_name);",
          "  }",
          "  return 0;",
          "}"
        ],
        "jn_code" : [
          "// C++: void getFeaturesForDisplay(std::map<std::string, std::vector<std::vector<double> > > &mapOfFeatures)",
          "private static native double[][][] getFeaturesForDisplay(long address);"
        ]
      },
      "getCameraNames" : {
        "j_code" : [
          "//",
          "// manual port",
          "// C++: void getCameraNames()",
          "//",
          "//javadoc: VpMbGenericTracker::getCameraNames()\n",
          "public String[] getCameraNames()",
          "{",
          "   return getCameraNames(nativeObj);",
          "}"
        ],
        "cpp_code" : [
          "//",
          "// manual port",
          "// void getCameraNames()",
          "//\n",
          "JNIEXPORT jobjectArray JNICALL Java_org_visp_mbt_VpMbGenericTracker_getCameraNames (JNIEnv*, jclass, jlong);\n",
          "JNIEXPORT jobjectArray JNICALL Java_org_visp_mbt_VpMbGenericTracker_getCameraNames",
          "  (JNIEnv* env, jclass , jlong address)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::getCameraNames()\";",
          "  try {",
          "   LOGD(\"%s\", method_name);",
          "   vpMbGenericTracker *tracker = (vpMbGenericTracker*) address;",
          "   std::vector<std::string> cameraNames = tracker->getCameraNames();",
          "   return vector_string_to_array_native(env, cameraNames);",
          "  } catch(const std::exception &e) {",
          "   throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "   throwJavaException(env, 0, method_name);",
          "  }",
          "  return 0;",
          "}"
        ],
        "jn_code" : [
          "// C++: void getCameraNames()",
          "private static native String[] getCameraNames(long address);"
        ]
      },
      "getReferenceCameraName" : {
        "j_code" : [
          "//",
          "// manual port",
          "// C++: std::string getReferenceCameraName()",
          "//",
          "//javadoc: VpMbGenericTracker::getReferenceCameraName()\n",
          "public String getReferenceCameraName()",
          "{",
          "   return getReferenceCameraName(nativeObj);",
          "}"
        ],
        "cpp_code" : [
          "//",
          "// manual port",
          "// std::string getReferenceCameraName()",
          "//\n",
          "JNIEXPORT jstring JNICALL Java_org_visp_mbt_VpMbGenericTracker_getReferenceCameraName (JNIEnv*, jclass, jlong);\n",
          "JNIEXPORT jstring JNICALL Java_org_visp_mbt_VpMbGenericTracker_getReferenceCameraName",
          "  (JNIEnv* env, jclass , jlong address)",
          "{",
          "  static const char method_name[] = \"vpMbGenericTracker::getReferenceCameraName()\";",
          "  try {",
          "   LOGD(\"%s\", method_name);",
          "   vpMbGenericTracker *tracker = (vpMbGenericTracker*) address;",
          "   return convertTo(env, tracker->getReferenceCameraName());",
          "  } catch(const std::exception &e) {",
          "   throwJavaException(env, &e, method_name);",
          "  } catch (...) {",
          "   throwJavaException(env, 0, method_name);",
          "  }",
          "  return 0;",
          "}"
        ],
        "jn_code" : [
          "// C++: std::string getReferenceCameraName()",
          "private static native String getReferenceCameraName(long address);"
        ]
      }
    }
  }
}
